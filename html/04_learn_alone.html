<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Basics - Learning Alone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            line-height: 1.8;
            padding: 3rem;
            font-size: 1.1rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 4rem;
            color: #4fc3f7;
            margin-bottom: 1rem;
            text-align: center;
        }

        h2 {
            font-size: 2.5rem;
            color: #81d4fa;
            margin-bottom: 2rem;
            text-align: center;
            font-weight: normal;
        }

        .intro {
            background: #16213e;
            padding: 2.5rem;
            border-radius: 16px;
            margin-bottom: 3rem;
            border-left: 6px solid #4fc3f7;
            font-size: 2.0rem;
        }

        .intro p {
            margin-bottom: 1.5rem;
        }

        .intro p:last-child {
            margin-bottom: 0;
        }

        .highlight-safe {
            color: #64b5f6;
            font-weight: bold;
        }

        .highlight-poison {
            color: #ef5350;
            font-weight: bold;
        }

        .code-section {
            background: #0f0f23;
            padding: 2.5rem;
            border-radius: 16px;
            margin-bottom: 3rem;
            overflow-x: auto;
        }

        .code-section h3 {
            color: #4fc3f7;
            margin-bottom: 1.5rem;
            font-size: 3rem;
        }

        pre {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 1.8rem;
            line-height: 1.6;
        }

        .comment { color: #6a9955; }
        .keyword { color: #569cd6; }
        .type { color: #4ec9b0; }
        .function { color: #dcdcaa; }
        .number { color: #b5cea8; }
        .variable { color: #9cdcfe; }
        .operator { color: #d4d4d4; }
        .highlight-new {
            background: rgba(239, 83, 80, 0.3);
            border: 1px solid #ef5350;
            border-radius: 4px;
            padding: 0 4px;
        }

        .visualization-container {
            position: relative;
            background: #16213e;
            border-radius: 16px;
            padding: 2rem;
        }

        .graph-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
        }

        #graph {
            border-radius: 12px;
            display: block;
        }

        .weights-panel {
            top: 30px;
            right: 30px;
            background: rgba(30, 30, 50, 0.95);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #333;
            width: 48%;
        }

        .weight-control label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 6px;
        }

        .weights-panel h4 {
            text-align: center;
            margin-bottom: 20px;
            color: #fff;
            font-size: 1.6rem;
        }

        .weight-control {
            margin-bottom: 18px;
        }



        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-row span {
            font-size: 1.1rem;
            color: #888;
            min-width: 28px;
        }

        input[type="range"] {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            background: #444;
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .weight-value {
            font-size: 1.2rem;
            color: #4fc3f7;
            min-width: 50px;
            text-align: right;
        }

        .axis-labels {
            position: absolute;
            pointer-events: none;
            bottom: 0;
            left: 0;
        }

        .x-label {
            position: absolute;
            bottom: -55px;
            left: 80px;
            color: #aaa;
            font-size: 1.4rem;
            white-space: nowrap;
        }

        .y-label {
            position: absolute;
            left: -145px;
            top: -150px;
            transform: translateY(-50%) rotate(-90deg);
            color: #aaa;
            font-size: 1.4rem;
            white-space: nowrap;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 4rem;
            margin-top: 1.5rem;
            padding: 1rem;
            font-size: 1.4rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .legend-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .legend-dot.safe { background: #64b5f6; }
        .legend-dot.poison { background: #ef5350; }

        .nn-diagram {
            background: #0f0f23;
            padding: 2.5rem;
            border-radius: 16px;
            margin-bottom: 3rem;

        }

        .nn-diagram h3 {
            color: #4fc3f7;
            margin-bottom: 1.5rem;
            text-align: center;
            font-size: 3rem;
        }

        .nn-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5rem;
            padding: 2rem;
        }

        .nn-layer {
            display: flex;
            flex-direction: column;
            gap: 3rem;
            align-items: center;
        }

        .nn-node {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #2a2a4a;
            border: 5px solid #4fc3f7;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            color: #fff;
            text-align: center;
        }

        .nn-layer-label {
            font-size: 2.4rem;
            color: #888;
            text-align: center;
        }

        .nn-arrow {
            color: #666;
            font-size: 3rem;
        }

        .nn-weights-label {
            text-align: center;
            color: #888;
            font-size: 2.3rem;
        }

        .decision-rule {
            text-align: center;
            padding: 1.5rem;
            background: #1a1a3e;
            border-radius: 12px;
            margin-top: 1.5rem;
            font-size: 2.3rem;
        }

        .decision-rule p {
            margin: 0.8rem 0;
        }

        .problem-section {
            background: linear-gradient(135deg, #2d1f3d 0%, #1a1a2e 100%);
            padding: 3rem;
            border-radius: 16px;
            margin-top: 3rem;
            border: 3px solid #ef5350;
            text-align: center;
        }

        .problem-section h3 {
            color: #ef5350;
            font-size: 3rem;
            margin-bottom: 1.5rem;
        }

        .problem-section p {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            color: #ddd;
        }

        .problem-section .solution-teaser {
            font-size: 2.2rem;
            color: #4fc3f7;
            margin-top: 2rem;
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Neural Network Basics</h1>
        <h2>Letting the Network Learn on Its Own</h2>

        <div class="intro">
            <p>
                We cant<strong>manually adjust</strong> weights and biases.
                But real neural networks can learn alone!
            </p>
            <p>
                With <strong>Gradient Descent</strong>: measure how wrong the network is (cost),
                then nudge each weight in the direction that reduces the error.
            </p>
            <p>
                Other math solutions exists, and advanced AI uses multiple models and NN.
            </p>
        </div>

        <div class="nn-diagram">
            <h3>How Learning Works</h3>
            <div class="decision-rule">
                <p><strong>1. Cost Function</strong> — Measures how wrong the network is</p>
                <p style="margin-top: 0.5rem; color: #aaa;">Sum of squared differences between predictions and actual labels</p>
            </div>
            <div class="decision-rule" style="margin-top: 1rem;">
                <p><strong>2. Gradient</strong> — Which direction reduces the cost?</p>
                <p style="margin-top: 0.5rem; color: #aaa;">For each weight: nudge it slightly, see if cost goes up or down</p>
            </div>
            <div class="decision-rule" style="margin-top: 1rem;">
                <p><strong>3. Update</strong> — Move weights opposite to the gradient</p>
                <p style="margin-top: 0.5rem; color: #aaa;">weight -= learnRate × gradient</p>
            </div>
        </div>

        <div class="code-section">
            <h3>The Learning Code</h3>
            <pre><code><span class="comment">// Run a single iteration of Gradient Descent (using the finite-difference method)</span>
<span class="keyword">public void</span> <span class="function">Learn</span>(<span class="type">DataPoint</span>[] <span class="variable">trainingData</span>, <span class="keyword">double</span> <span class="variable">learnRate</span>)
{
    <span class="keyword">const double</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0.0001</span>;
    <span class="keyword">double</span> <span class="variable">originalCost</span> <span class="operator">=</span> <span class="function">Cost</span>(<span class="variable">trainingData</span>);

    <span class="keyword">foreach</span> (<span class="type">Layer</span> <span class="variable">layer</span> <span class="keyword">in</span> <span class="variable">layers</span>)
    {
        <span class="comment">// Calculate the cost gradient for the current weights</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">nodeIn</span> <span class="operator">=</span> <span class="number">0</span>; <span class="variable">nodeIn</span> <span class="operator">&lt;</span> <span class="variable">layer</span>.<span class="variable">numNodesIn</span>; <span class="variable">nodeIn</span><span class="operator">++</span>)
        {
            <span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">nodeOut</span> <span class="operator">=</span> <span class="number">0</span>; <span class="variable">nodeOut</span> <span class="operator">&lt;</span> <span class="variable">layer</span>.<span class="variable">numNodesOut</span>; <span class="variable">nodeOut</span><span class="operator">++</span>)
            {
                <span class="variable">layer</span>.<span class="variable">weights</span>[<span class="variable">nodeIn</span>, <span class="variable">nodeOut</span>] <span class="operator">+=</span> <span class="variable">h</span>;
                <span class="keyword">double</span> <span class="variable">deltaCost</span> <span class="operator">=</span> <span class="function">Cost</span>(<span class="variable">trainingData</span>) <span class="operator">-</span> <span class="variable">originalCost</span>;
                <span class="variable">layer</span>.<span class="variable">weights</span>[<span class="variable">nodeIn</span>, <span class="variable">nodeOut</span>] <span class="operator">-=</span> <span class="variable">h</span>;
                <span class="variable">layer</span>.<span class="variable">costGradientW</span>[<span class="variable">nodeIn</span>, <span class="variable">nodeOut</span>] <span class="operator">=</span> <span class="variable">deltaCost</span> <span class="operator">/</span> <span class="variable">h</span>;
            }
        }

        <span class="comment">// Calculate the cost gradient for the current biases</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">biasIndex</span> <span class="operator">=</span> <span class="number">0</span>; <span class="variable">biasIndex</span> <span class="operator">&lt;</span> <span class="variable">layer</span>.<span class="variable">biases</span>.<span class="variable">Length</span>; <span class="variable">biasIndex</span><span class="operator">++</span>)
        {
            <span class="variable">layer</span>.<span class="variable">biases</span>[<span class="variable">biasIndex</span>] <span class="operator">+=</span> <span class="variable">h</span>;
            <span class="keyword">double</span> <span class="variable">deltaCost</span> <span class="operator">=</span> <span class="function">Cost</span>(<span class="variable">trainingData</span>) <span class="operator">-</span> <span class="variable">originalCost</span>;
            <span class="variable">layer</span>.<span class="variable">biases</span>[<span class="variable">biasIndex</span>] <span class="operator">-=</span> <span class="variable">h</span>;
            <span class="variable">layer</span>.<span class="variable">costGradientB</span>[<span class="variable">biasIndex</span>] <span class="operator">=</span> <span class="variable">deltaCost</span> <span class="operator">/</span> <span class="variable">h</span>;
        }
    }

    <span class="function">ApplyAllGradients</span>(<span class="variable">learnRate</span>); <span class="comment">// Calls ApplyGradients() on all layers</span>
}</code></pre>
        </div>

        <div class="visualization-container">
            <h2>it will takes some time! (about 6K iterations)</h2>
            <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 1.5rem; align-items: center; flex-wrap: wrap;">
                <button id="startBtn" style="padding: 1rem 3rem; font-size: 1.8rem; background: #4fc3f7; color: #1a1a2e; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">Start Learning</button>
                <button id="stopBtn" style="padding: 1rem 3rem; font-size: 1.8rem; background: #ef5350; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; display: none;">Stop</button>
                <div style="background: rgba(30, 30, 50, 0.95); padding: 1rem 2rem; border-radius: 8px; border: 2px solid #333;">
                    <span style="color: #aaa; font-size: 1.4rem;">Correct: </span>
                    <span id="accuracyDisplay" style="color: #4fc3f7; font-size: 1.8rem; font-weight: bold;">0/0</span>
                </div>
                <div style="background: rgba(30, 30, 50, 0.95); padding: 1rem 2rem; border-radius: 8px; border: 2px solid #333;">
                    <span style="color: #aaa; font-size: 1.4rem;">Cost: </span>
                    <span id="costDisplay" style="color: #4fc3f7; font-size: 1.8rem; font-weight: bold;">0.000</span>
                </div>
                <div style="background: rgba(30, 30, 50, 0.95); padding: 1rem 2rem; border-radius: 8px; border: 2px solid #333;">
                    <span style="color: #aaa; font-size: 1.4rem;">Iteration: </span>
                    <span id="iterDisplay" style="color: #4fc3f7; font-size: 1.8rem; font-weight: bold;">0</span>
                </div>
            </div>
            <div class="graph-wrapper">
                <div class="axis-labels">
                    <div class="x-label">Spot Size →</div>
                    <div class="y-label">Spike Length →</div>
                </div>
            </div>

            <canvas id="graph" width="1400" height="800"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot safe"></div>
                    <span>Safe Fruit</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot poison"></div>
                    <span>Poisonous Fruit</span>
                </div>
            </div>
        </div>

        <div class="problem-section" style="border-color: #4fc3f7;">
            <h3 style="color: #4fc3f7;">The Network Learns!</h3>
            <p>
                Watch the <strong>cost decrease</strong> as the network adjusts its weights and biases.
            </p>
            <p>
                The decision boundary will curve and shift until it correctly classifies the fruits.
            </p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        const MIN_COORD = -0.05, MAX_COORD = 1.0, COORD_RANGE = MAX_COORD - MIN_COORD;
        const safeDotColor = '#64b5f6', poisonDotColor = '#ef5350';

        // Generate fruits (training data)
        const fruits = [];
        let seed = 42;
        const seededRandom = () => { const x = Math.sin(seed++) * 10000; return x - Math.floor(x); };
        for (let i = 0; i < 100; i++) {
            const normX = seededRandom(), normY = seededRandom();
            fruits.push({ normX, normY, safe: Math.sqrt(normX * normX + normY * normY) < 0.5 });
        }
        const totalSafe = fruits.filter(f => f.safe).length;

        // Network weights - start near zero with tiny perturbation to break symmetry
        let w1 = [[0, 0, 0], [0, 0, 0]];  // 2 inputs -> 3 hidden
        let b1 = [0, 0, 0];
        let w2 = [[0, 0], [0, 0], [0, 0]];  // 3 hidden -> 2 outputs
        let b2 = [0, 0];

        // Gradient storage
        let gw1 = [[0, 0, 0], [0, 0, 0]];
        let gb1 = [0, 0, 0];
        let gw2 = [[0, 0], [0, 0], [0, 0]];
        let gb2 = [0, 0];

        function initWeights() {
            // Larger random values for meaningful gradients with sigmoid
            // Need weights ~±3-6 to get hidden neurons to saturate in different regions
            for (let i = 0; i < 2; i++) for (let j = 0; j < 3; j++) w1[i][j] = (Math.random() - 0.5) * 4;
            for (let i = 0; i < 3; i++) b1[i] = (Math.random() - 0.5) * 4;
            for (let i = 0; i < 3; i++) for (let j = 0; j < 2; j++) w2[i][j] = (Math.random() - 0.5) * 4;
            for (let i = 0; i < 2; i++) b2[i] = (Math.random() - 0.5) * 4;
        }
        initWeights();

        const sigmoid = x => 1 / (1 + Math.exp(-x));

        // Forward pass - returns [o0, o1]
        function forward(x, y) {
            let h0 = sigmoid(b1[0] + x * w1[0][0] + y * w1[1][0]);
            let h1 = sigmoid(b1[1] + x * w1[0][1] + y * w1[1][1]);
            let h2 = sigmoid(b1[2] + x * w1[0][2] + y * w1[1][2]);
            let o0 = sigmoid(b2[0] + h0 * w2[0][0] + h1 * w2[1][0] + h2 * w2[2][0]);
            let o1 = sigmoid(b2[1] + h0 * w2[0][1] + h1 * w2[1][1] + h2 * w2[2][1]);
            return [o0, o1];
        }

        // Cost function - sum of squared errors
        function cost() {
            let total = 0;
            for (const f of fruits) {
                const [o0, o1] = forward(f.normX, f.normY);
                const target0 = f.safe ? 1 : 0;
                const target1 = f.safe ? 0 : 1;
                total += (o0 - target0) ** 2 + (o1 - target1) ** 2;
            }
            return total / fruits.length;
        }

        // Count correct predictions
        function countCorrect() {
            let correct = 0;
            for (const f of fruits) {
                const [o0, o1] = forward(f.normX, f.normY);
                const predictSafe = o0 > o1;
                if (predictSafe === f.safe) correct++;
            }
            return correct;
        }

        // Gradient descent step - compute ALL gradients first, then apply
        function learn(learnRate) {
            const h = 0.0001;
            const originalCost = cost();

            // Step 1: Compute all gradients (store them, don't apply yet)
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 3; j++) {
                    w1[i][j] += h;
                    gw1[i][j] = (cost() - originalCost) / h;
                    w1[i][j] -= h;
                }
            }
            for (let i = 0; i < 3; i++) {
                b1[i] += h;
                gb1[i] = (cost() - originalCost) / h;
                b1[i] -= h;
            }
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    w2[i][j] += h;
                    gw2[i][j] = (cost() - originalCost) / h;
                    w2[i][j] -= h;
                }
            }
            for (let i = 0; i < 2; i++) {
                b2[i] += h;
                gb2[i] = (cost() - originalCost) / h;
                b2[i] -= h;
            }

            // Step 2: Apply all gradients at once
            for (let i = 0; i < 2; i++) for (let j = 0; j < 3; j++) w1[i][j] -= learnRate * gw1[i][j];
            for (let i = 0; i < 3; i++) b1[i] -= learnRate * gb1[i];
            for (let i = 0; i < 3; i++) for (let j = 0; j < 2; j++) w2[i][j] -= learnRate * gw2[i][j];
            for (let i = 0; i < 2; i++) b2[i] -= learnRate * gb2[i];
        }

        function toCanvasX(x) { return ((x - MIN_COORD) / COORD_RANGE) * width; }
        function toCanvasY(y) { return height - ((y - MIN_COORD) / COORD_RANGE) * height; }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            const step = 5;

            for (let cy = 0; cy < height; cy += step) {
                for (let cx = 0; cx < width; cx += step) {
                    const x = (cx / width) * COORD_RANGE + MIN_COORD;
                    const y = ((height - cy) / height) * COORD_RANGE + MIN_COORD;
                    const [o0, o1] = forward(x, y);
                    const pred = o0 > o1 ? 0 : 1;
                    const r = pred === 0 ? 70 : 165;
                    const g = pred === 0 ? 130 : 60;
                    const b = pred === 0 ? 180 : 60;

                    for (let dy = 0; dy < step && cy + dy < height; dy++) {
                        for (let dx = 0; dx < step && cx + dx < width; dx++) {
                            const idx = ((cy + dy) * width + (cx + dx)) * 4;
                            data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath(); ctx.moveTo(width / 10 * i, 0); ctx.lineTo(width / 10 * i, height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, height / 10 * i); ctx.lineTo(width, height / 10 * i); ctx.stroke();
            }

            // Axes
            const ox = toCanvasX(0), oy = toCanvasY(0);
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(width, oy); ctx.stroke();

            // Fruits
            fruits.forEach(f => {
                ctx.beginPath();
                ctx.arc(toCanvasX(f.normX), toCanvasY(f.normY), 8, 0, Math.PI * 2);
                ctx.fillStyle = f.safe ? safeDotColor : poisonDotColor;
                ctx.fill();
            });
        }

        // Training loop
        let isTraining = false;
        let iteration = 0;
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const costDisplay = document.getElementById('costDisplay');
        const iterDisplay = document.getElementById('iterDisplay');
        const accuracyDisplay = document.getElementById('accuracyDisplay');

        function updateDisplay() {
            costDisplay.textContent = cost().toFixed(4);
            iterDisplay.textContent = iteration;
            accuracyDisplay.textContent = countCorrect() + '/' + fruits.length;
        }

        function trainStep() {
            if (!isTraining) return;
            // Do multiple learning steps per frame for faster convergence
            for (let i = 0; i < 5; i++) {
                learn(2.0);
                iteration++;
            }
            updateDisplay();
            draw();
            requestAnimationFrame(trainStep);
        }

        startBtn.addEventListener('click', () => {
            if (isTraining) return;
            initWeights();
            iteration = 0;
            isTraining = true;
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            trainStep();
        });

        stopBtn.addEventListener('click', () => {
            isTraining = false;
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            startBtn.textContent = 'Restart';
        });

        // Initial draw
        updateDisplay();
        draw();
    </script>
</body>
</html>
